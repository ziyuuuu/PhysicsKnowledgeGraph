# -*- coding: utf-8 -*-
"""CS6216 knowledge graph creation and expansion experiments.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EP_2a78VLmzJW7g9ySgq53EMQvFOm65t
"""

import networkx as nx
import sys
sys.path.append('/content/drive/MyDrive')
import cs6216_taylor_series_identification as TSI
import math
import numpy as np



# def multiplication1(arr1, arr2):
#   [a,b,c,d,e,f,g,h,i,j] = arr1
#   [A,B,C,D,E,F,G,H,I,J] = arr2 
#   return [a*A, a*B+b*A, a*C+b*B+c*A, a*D+b*C+c*B+d*A, 
#           a*E+b*D+c*C+d*B+e*A, a*F+b*E+c*D+d*C+e*B+f*A, a*G+b*F+c*E+d*D+e*C+f*B+g*A,
#           a*H+b*G+c*F+d*E+e*D+f*C+g*B+h*A, a*I+b*H+c*G+d*F+e*E+f*D+g*C+h*B+i*A, a*J+b*I+c*H+d*G+e*F+f*E+g*D+h*C+i*B+j*A, b*J+c*I+d*H+e*G+f*F+g*E+h*D+i*C+j*B]

def multiplication(arr1, arr2):
  matrix = np.fliplr(np.outer(np.asarray(arr1, dtype = np.float32), np.asarray(arr2, dtype = np.float32)))
  output = []
  starting_offset = int(np.floor(0.25*(len(arr1)+len(arr2))))
  for i in range(len(arr1)-1, -len(arr1)+1,-1):
    output.append(np.trace(matrix, offset=i))
  return output

def function_compositionality(arr1, arr2): #where both arrays represent functions and function compositionality is done as: arr1(arr2)
  power_results = []
  power_results.append(arr2)
  for i in range(len(arr1)-2):
    power_results.append(multiplication(power_results[i], arr2)[0:len(arr1)])
  power_results = np.asarray(power_results, dtype = np.float32)
  output = np.sum(np.multiply(np.asarray(arr1[1:len(arr1)], dtype=np.float32)[:, np.newaxis],power_results), axis = 1)
  output = np.insert(output, 0, arr1[0])
  print(output)
  return output

def create_initial_knowledge_graph(series_length = 10):
  #this function creates a simple directed graph with nodes representing inputs and outputs of functions (like X, sin(X), ln(X), sin(X)+ln(X), etc)
  #and edges representing operators 
  G=nx.Graph()
  #start of the graph:
  G.add_node("X", taylor_series = [0+1*(i==1) for i in range(series_length)])
  # 1 step away:]
  G.add_node("sine(X)", taylor_series = [-1/math.factorial(i)*(i%2 != 0)*((i+1)%4==0)+1/math.factorial(i)*((i+3)%4 == 0) for i in range(series_length)])
  G.add_edge("X", "sine(X)")
  G.add_node("cosine(X)", taylor_series = [1/math.factorial(i)*(i%4 == 0) + -1/math.factorial(i)*((i+2)%4 == 0) for i in range(series_length)])
  G.add_edge("X", "cosine(X)")
  G.add_node("exponential(X)", taylor_series = [1/math.factorial(i)*(i!=0) for i in range(series_length)])
  G.add_edge("X", "exponential(X)")
  G.add_node("quadr(X)", taylor_series =  [0+1*(i==2) for i in range(series_length)])
  G.add_edge("X", "quadr(X)")
  G.add_node("cubic(X)", taylor_series =  [0+1*(i==3) for i in range(series_length)])
  G.add_edge("X", "cubic(X)")
  return G

def print_outcomes(pct):
  possible_answers = set(pct)
  output = []
  for i in possible_answers:
    output.append([i, sum(list(map(int, pct == i)))/len(pct)])
  return output

